<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 2 Programming Project</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the prototype approach.
//       This is not what the book uses, so you have to convert it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//---------//
// Project //
//---------//
console.log("Project");

// 1. Implement the stack data structure using the prototype.
function Queue() {
  // properties and methods go here
this.items=[];

Queue.prototype.enqueue = function(element){
  items.push(element);
};
Queue.prototype.dequeue = function(){
  return this.items.shift();
};
Queue.prototype.front = function(){
  return this.items[0];
};
Queue.prototype.isEmpty = function () {
  return this.items.length == 0;
};
Queue.prototype.size =function () {
  return this.items.length;
};
Queue.prototype.print = function (){
  console.log(this.items);
};
}
var queue = new Queue();
Queue.enqueue(5);
Queue.enqueue(4);
Queue.enqueue(3);
Queue.enqueue(2);
Queue.enqueue(1);

// 2. It is possible to use a stack to check if the number of parentheses in a
//    string is balanced, meaning there are as many opening parentheses as
//    closing ones. In addition, we can also make sure that each opening
//    parenthesis precedes a closing parenthesis. Implement this algorithm.
//    HINT: When encountering '(' push to the stack and when encountering ')'
//    pop from the stack.

let isMatchingBrackets = function (str) {
    let stack = [];
    let map = {
        '(': ')',
        '[': ']',
        '{': '}'
    }

    for (let i = 0; i < str.length; i++) {

        // If character is an opening brace add it to a stack
        if (str[i] === '(' || str[i] === '{' || str[i] === '[' ) {
            stack.push(str[i]);
        }
        //  If that character is a closing brace, pop from the stack, which will also reduce the length of the stack each time a closing bracket is encountered.
        else {
            let last = stack.pop();

            //If the popped element from the stack, which is the last opening brace doesn’t match the corresponding closing brace in the map, then return false
            if (str[i] !== map[last]) {return false};
        }
    }
    // By the completion of the for loop after checking all the brackets of the str, at the end, if the stack is not empty then fail
        if (stack.length !== 0) {return false};

    return true;
}
// 3. Write a simple test program that shows your implementation in the
//    previous question works.

console.log(isMatchingBrackets("(){}")); // returns true
console.log(isMatchingBrackets("[{()()}({[]})]({}[({})])((((((()[])){}))[]{{{({({({{{{{{}}}}}})})})}}}))[][][]")); // returns true
console.log(isMatchingBrackets("({(()))}}")); // returns false

// 4. Implement the queue data structure using the prototype.


let isMatchingBracketsPro = function (str) {
    let stack = [];
    let map = {
        '(': ')',
        '[': ']',
        '{': '}'
    }

    for (let i = 0; i < str.length; i++) {

        // If character is an opening brace add it to a stack
        if (str[i] === '(' || str[i] === '{' || str[i] === '[' ) {
            stack.prototype.push(str[i]);
        }
        //  If that character is a closing brace, pop from the stack, which will also reduce the length of the stack each time a closing bracket is encountered.
        else {
            let last = stack.prototype.pop();

            //If the popped element from the stack, which is the last opening brace doesn’t match the corresponding closing brace in the map, then return false
            if (str[i] !== map[last]) {return false};
        }
    }
    // By the completion of the for loop after checking all the brackets of the str, at the end, if the stack is not empty then fail
        if (stack.length !== 0) {return false};

    return true;
}

console.log(isMatchingBracketsPro("(){}")); // returns true
console.log(isMatchingBracketsPro("[{()()}({[]})]({}[({})])((((((()[])){}))[]{{{({({({{{{{{}}}}}})})})}}}))[][][]")); // returns true
console.log(isMatchingBracketsPro("({(()))}}")); // returns false

// 5. Create a queue that stores edibles, that can be either fruits or
//    vegetables. Use the constructor below to create the edible and store a
//    few of each kind in the queue (at least 3 of each).

function Edible(name, isFruit) {
  this.name = name;
  this.isFruit = isFruit; // if not fruit, it must be a vegetable
  this.toString = function() {
    return "Edible: " + this.name + " Fruit: " + this.isFruit;
  };
}

// ... put your code here ...

function QueueEd() {
  // properties and methods go here
let items = [];

this.enqueue = function(element){
  items.push(element);
};
this.dequeue = function(){
  return items.shift();
};
this.front = function(){
  return items[0];
};
This.isEmpty = function () {
  return items.length == 0;
};
this.size =function () {
  return items.length;
};
this.print = function (){
  console.log(items.toString());
};
}

QueueEd.enqueue('Apple');
QueueEd.enqueue('Yuzu');
QueueEd.enqueue('Clementine');
QueueEd.enqueue('Artichoke');
QueueEd.enqueue('Bamboo Shoots');
QueueEd.enqueue('Cauliflower');

// 6. Create two more queues: one for fruits and one for vegetables. For this
//    question, only create them (and leave them empty).
function QueueFruits() {
  // properties and methods go here
let items = [];

this.enqueue = function(element){
  items.push(element);
};
this.dequeue = function(){
  return items.shift();
};
this.front = function(){
  return items[0];
};
This.isEmpty = function () {
  return items.length == 0;
};
this.size =function () {
  return items.length;
};
this.print = function (){
  console.log(items.toString());
};
}

function QueueVeg() {
  // properties and methods go here
let items = [];

this.enqueue = function(element){
  items.push(element);
};
this.dequeue = function(){
  return items.shift();
};
this.front = function(){
  return items[0];
};
This.isEmpty = function () {
  return items.length == 0;
};
this.size =function () {
  return items.length;
};
this.print = function (){
  console.log(items.toString());
};
}

// 7. Dequeue all the elements from the edible queue and enqueue them in the
//    appropriate queue, either for fruits or vegetables.

QueueEd.dequeue('Apple');
QueueEd.dequeue('Yuzu');
QueueEd.dequeue('Clementine');
QueueEd.dequeue('Artichoke');
QueueEd.dequeue('Bamboo Shoots');
QueueEd.dequeue('Cauliflower');

QueueFruits.enqueue('Apple');
QueueFruits.enqueue('Yuzu');
QueueFruits.enqueue('Clementine');
QueueVeg.enqueue('Artichoke');
QueueVeg.enqueue('Bamboo Shoots');
QueueVeg.enqueue('Cauliflower');

// 8. Print the final contents to the console, showing that your code works.

QueueFruits.print();
QueueVeg.print();

</script>
</head>
<body>
  See console!
</body>
</html>
